
// Steps: Use case to be executed based on clients current attendance state
// All the steps implement the following class 
export default abstract class StepDefinition implements IStepOptions {
  Customer: Customer;
  Message: Message;
  SessionData: SessionData;
  Answer : string;
  OrderInfo?: Order;
  Address?: CustomerAddress;
  ADDRESS_STEP: boolean;
  ORDER_STEP: boolean;

  constructor({ customer , message , sessionData } : StepDefinitionArgs) {
    this.Customer = customer
    this.Message = message
    this.SessionData = sessionData
    this.Answer = message.body
    this.OrderInfo = null
    this.Address = null
    this.ADDRESS_STEP = false
    this.ORDER_STEP = false
  }


  async Interact() : Promise<StepInfo> {
    throw new Error("Mot implemented")
  }
}

// After interacion each step returns this object which contains the output for the customer and some extra info
export default class StepInfo implements IStepInfo {
  outboundMessages: string[];
  nextStep: number;
  requiredAction: ActionsEnum[]
  actionPayload: Payload[]
  /**
   *
   */
  constructor(
    outboundMessages : string[],
    nextStep? : number,
    requiredAction? : ActionsEnum[],
    actionPayload? : Payload[]
  ) {
    this.outboundMessages = outboundMessages
    this.nextStep = nextStep
    this.requiredAction = requiredAction
    this.actionPayload = actionPayload
  }
}

// Main bot flow
@Service()
export default class BotCore {
  private bot: Whatsapp;
  private sessionData : SessionData

  constructor(
    private readonly SessionHandler : SessionHandler,
    private readonly TaonHandler : TaonHandler,
    private readonly UserDataHandler : UserDataHandler,
    private readonly OrderRepository : OrderRepository,
    private readonly AddressesRepository : AddressesRepository
    ) {
      this.sessionData = {
        branchData: null,
        startupDate: null,
        inMemoryData: null,
      }
    }

  public Start() {
    this.bot.onMessage(async (inboundMessage: Message) => {
      // Message is Received and validated
      if (this.IsValidMessage(inboundMessage)) {
        // Customer info properlly created on cache or downloaded from backend (if it is his first message of the day) and saved on cache
        const { stepInfo, customer } = await this.HandleMessage(inboundMessage)

        // If the interaction with the step has changed user state it is updated on cache
        if (stepInfo.nextStep) await this.SessionHandler.UpdateClientStep(customer, stepInfo.nextStep)

        // the message generated by the use case is sent to the client
        await this.SendMessages(stepInfo.outboundMessages, customer)
        
        // If the step generated an action / command that must be performed (HTTP request) it is done at the end
        await this.HandleStepAction(stepInfo, customer)
      } else {
        // No actions for messages received from groups
      }
    })
  }

  private async HandleMessage(inboundMessage: Message) : Promise<HandledMessage> {
    const { 
      customer, 
    } = await this.MessageSetup(inboundMessage)

    // Based on user current step the stepHandler will be created, this handler represents the use case related to the step of the attendance the customer is at the moment
    const stepHandler = StepFactory.Create(customer.currentStep, {
      customer,
      message: inboundMessage,
      sessionData: { ...this.sessionData },
    })

    // Some info is passed to stepHandler via DI
    await this.EnrichStepHandler(stepHandler, customer)

    // The use case is executed
    const stepInfo = await stepHandler.Interact()

    return {
      stepInfo,
      customer
    }
  }

  async EnrichStepHandler(stepHandler: StepDefinition, customer: Customer) : Promise<void> {
    let orderInfo = null
    let address = null

    if (stepHandler.ORDER_STEP) {
      orderInfo = await this.OrderRepository.GetClientOrders(customer._id)
    }

    if (stepHandler.ADDRESS_STEP) {
      address = await this.AddressesRepository.GetClientAddresses(customer._id)
    }

    stepHandler.Address = address
    stepHandler.OrderInfo = orderInfo
  }

  private async MessageSetup(inboundMessage: Message) : Promise<SetupInfo> {
    const customer = await this.SessionHandler.CheckIn(inboundMessage)

    const branchData = await this.UserDataHandler.UpdateTemplateMessages(
      customer.lastMessage, this.sessionData.branchData
    )   
    
    this.SetBranchData(branchData)

    return {
      customer,
    }
  }

  private async SendMessages(outboundMessages : string[], customer : Customer) {
    for (const outboundMessage of outboundMessages) {
      await this.bot.sendText(customer.info.whatsappId, outboundMessage)
    }
  }

  private async HandleStepAction(stepInfo: StepInfo, customer: Customer) {
    if (stepInfo.requiredAction && !!stepInfo.requiredAction.length) {
      for (let index = 0; index <= stepInfo.requiredAction.length - 1; index += 1) {
        const action = stepInfo.requiredAction[index]
        const actionHandler = ActionsFactory.Create(action)
        const postActionStep = await actionHandler
          .DispatchAction(stepInfo.actionPayload[index], customer, this.sessionData)

        if (postActionStep) {
          if (postActionStep.nextStep) await this.SessionHandler.UpdateClientStep(customer, postActionStep.nextStep)
          await this.SendMessages(postActionStep.outboundMessages, customer)
          await this.HandleStepAction(postActionStep, customer)
        }
      }
    }
  }

  private IsValidMessage(inboundMessage: Message) {
    if (process.env.TEST_WHATAPP_NUMBER) {
      return !inboundMessage.isGroupMsg && inboundMessage.from === process.env.TEST_WHATAPP_NUMBER
    }
    return !inboundMessage.isGroupMsg
  }

  public SetBot(bot: any) {
    this.bot = bot
  }

  public SetBranchData(branchData: BranchData) {
    this.sessionData.branchData = branchData
  }

  public SetStartupDate(startupDate: Date) {
    this.sessionData.startupDate = startupDate
  }

  public SetMemoryData(data: MemoryData) {
    this.sessionData.inMemoryData = data
  }
}